#ifndef SERVER_H
#define SERVER_H

#include <QCoreApplication>
#include <QWebSocketServer>
#include <QWebSocket>
#include <QMap>
#include <QJsonDocument>
#include <QJsonObject>
#include <QDebug>
#include <QObject>

/*Этот класс предназначен для реализации сервера, а также игровой логики приложения.*/

class GameServer : public QObject {
    Q_OBJECT

public:
    /**
     * \brief Конструктор для класса GameServer.
     * \param port Порт, на котором будет запущен сервер.
     * \param parent Родительский объект, который передается в конструктор базового класса QObject.
     *
     * Этот конструктор инициализирует объект `QWebSocketServer` и запускает сервер на указанном порту.
     * Если сервер успешно запускается, он подключает слот для обработки новых соединений.
     * В случае неудачи выводится сообщение об ошибке.
     *
     */
    GameServer(const quint16 port, QObject *parent = nullptr);

private:
    /*!
     * \brief Метод служит для отправки всем подключенным клиентам сообщения
     * \param message строка, сообщение полученное от клиента
     *
     * Метод ответственный за оповещение всех клиентов о созданной комнате.
    Для этого объект, который несет в себе информацию о создании новой комнаты и
    само название этой комнаты преобразуется в строку, которая с помощью метода sendTextMessage
    рассылается всем клиентам.
    */
    void broadcastMessage(const QJsonObject &message);
    /*!
     * \brief
     * \param message строка, сообщение полученное от клиента
     *
     * Данный метод отвечает за обработку полученных от клиента сообщений.
    Изначально мы анализируем, от кого пришла информация. Далее проверяем,
    валидное ли сообщение получено. После прохождения проверки преобразуем сообщение
    в объект и получаем его тип.Далее уже предусмотрены три варианта:
        1) Тип сообщения == "create_room". В данном случае мы получаем имя комнаты, которая
    должна быть создана и если такой комнаты не существует, то создаем ее, при этом добавив
    создателя в нее, уведомив его, а также уведомив всех подключенных клиентов осозданной комнате.
    Если же такая комната уже существует, то уведомляем пользователя об этом.
        2) Тип сообщения == "join_room". Здесь мы проверяем, имеется ли комната с таким названием,
    а также свободно ли в ней место. Если условия выполняются, то добавляем пользователя в комнату
    и отправляем обоим игрокам сообщение "game_start".
    Иначе Отправляем сообщение об ошибке.
        3) Тип сообщение == "play". Здесь перенаправляем выбранный игроком объект в
    метод handleGameMovce() который решает, кто победил.
    */
    void processMessage(const QString& message);
    /**
     * \brief Обрабатывает ход игры от клиента.
     * \param socket Указатель на объект QWebSocket, представляющий клиента, сделавшего ход.
     * \param obj JSON-объект, содержащий выбор игрока (ключ "choice").
     *
     * Метод извлекает выбор игрока из JSON-объекта, определяет, в какой комнате находится
     * игрок, и сохраняет его ход. Если оба игрока в комнате сделали выбор, определяется победитель
     * с помощью функции `determineWinner` и отправляется результат игры всем участникам комнаты.
     *
     * Если игрок не находится в комнате (например, из-за ошибки), метод ничего не делает.
     */
    void handleGameMove(const QWebSocket *socket, const QJsonObject& obj);
    /**
     * \brief Отправляет сообщение клиенту.
     * \param socket Указатель на объект QWebSocket, представляющий клиента, которому нужно отправить сообщение.
     * \param message JSON-объект, который будет отправлен клиенту.
     *
     * Метод преобразует переданный JSON-объект в строку с помощью QJsonDocument::toJson() в компактном формате
     * и отправляет его клиенту с помощью метода sendTextMessage().
     */
    void sendToClient(QWebSocket *socket, const QJsonObject& message);
    /**
     * \brief Отправляет сообщение всем участникам комнаты.
     * \param roomName Название комнаты, в которой находятся участники, которым нужно отправить сообщение.
     * \param message JSON-объект, который будет отправлен всем участникам комнаты.
     *
     * Метод извлекает пару сокетов (игроков) из комнаты по ее имени и отправляет сообщение каждому клиенту,
     * который подключен к комнате. Сообщение отправляется через метод sendToClient.
     * Если один из игроков отключен (например, room.first или room.second равны nullptr), сообщение не будет отправлено этому клиенту.
     */
    void sendToRoom(const QString &roomName, const QJsonObject& message);
    /**
     * \brief Получает имя комнаты для указанного сокета.
     * \param socket Указатель на объект QWebSocket, для которого нужно получить имя комнаты.
     *
     * Метод проходит по всем комнатам на сервере и проверяет, является ли указанный сокет первым или вторым
     * игроком в комнате. Если сокет найден, возвращается имя комнаты. Если сокет не найден в любых комнатах,
     * метод возвращает пустую строку.
     */
    QString getSocketsRoomName(const QWebSocket *socket);
    /**
     * \brief Перезапускает игру в указанной комнате.
     * \param roomName Название комнаты, для которой нужно перезапустить игру.
     *
     * Метод даляет текущие ходы из структуры данных, связанной с данной комнатой (очищает информацию о ходах).
     * \todo На данный момент метод не реализован и не использован, потребуется доработка.
     */
    void restartGame(const QString &roomName);
    /**
     * \brief Завершается игра в указанной комнате..
     *
     * \param roomName Название комнаты, для которой необходимо завершить игру.
     *
     * Метод удаляет данные о структуре из комнаты, удаляя информации о самой комнате, а также удаляет данные о выполненных ходах
     */
    void exitGame(const QString &roomName);
    /**
     * \brief Определяет победителя между двумя игроками.
     * \param p1 Выбор игрока 1 (строка: "rock", "paper", или "scissors").
     * \param p2 Выбор игрока 2 (строка: "rock", "paper", или "scissors").
     *
     * Этот метод сравнивает выборы двух игроков (p1 и p2) в игре "Камень, ножницы, бумага" и
     * определяет победителя. Если выборы игроков одинаковы, возвращается результат "ничья".
     * В противном случае, метод определяет, кто выиграл в зависимости от выбранных ходов.
     */
    QString determineWinner(const QString &p1, const QString &p2);

private slots:
    /**
     * \brief Обрабатывает новое подключение клиента.
     *
     * Этот метод вызывается при установлении нового соединения с сервером. Он получает новый сокет,
     * подключает его к слотам для обработки полученных сообщений и отключений, а также добавляет его в список клиентов.
     *
     * При установлении нового соединения сервер получает объект `QWebSocket`, который представляет новое подключение.
     * После этого метод выполняет следующие действия:
     * - Подключает сигнал `textMessageReceived` сокета к слоту `processMessage`, который будет обрабатывать полученные текстовые сообщения.
     * - Подключает сигнал `disconnected` сокета к слоту `onClientDisconnected`, который будет вызываться при отключении клиента.
     * - Добавляет сокет в контейнер `clients`, чтобы отслеживать активных клиентов.
     * - Выводит в лог информацию о том, что новый клиент подключился.
     */
    void onNewConnection();
    /**
     * \brief Обрабатывает отключение клиента.
     *
     * Этот метод вызывается, когда клиент отключается от сервера. Он проверяет, была ли комната, в которой находился клиент,
     * и если такая комната существует, отправляет уведомление остальным игрокам о том, что противник покинул игру. Также
     * удаляет информацию о комнате и очищает связанные данные.
     *
     * При отключении клиента метод выполняет следующие шаги:
     * - Логирует событие отключения клиента с помощью `Info()`.
     * - Получает сокет отключившегося клиента с помощью `sender()`.
     * - Проходит по всем комнатам на сервере и проверяет, связан ли сокет с какой-либо из них (первый или второй игрок).
     * - Если клиент был в комнате, отправляется сообщение остальным игрокам о том, что противник покинул игру, после чего
     *   информация о комнате и сделанных ходах удаляется.
     * - Отключенный сокет удаляется из контейнера `clients` и объект `QWebSocket` помечается для удаления с помощью `deleteLater()`.
     */
    void onClientDisconnected();

private:
    QWebSocketServer *server;
    QSet<QWebSocket *> clients;
    QMap<QString, QPair<QWebSocket *, QWebSocket *>> rooms;
    QMap<QString, QPair<QString, QString>> moves;

};

#endif // SERVER_H
