#ifndef SERVER_H
#define SERVER_H

#include <QCoreApplication>
#include <QWebSocketServer>
#include <QWebSocket>
#include <QMap>
#include <QJsonDocument>
#include <QJsonObject>
#include <QDebug>
#include <QObject>

/*Этот класс предназначен для реализации сервера, а также игровой логики приложения.*/

class GameServer : public QObject {
    Q_OBJECT

public:
    GameServer(quint16 port, QObject *parent = nullptr);

private:
    /*Метод ответственный за оповещение всех клиентов о созданной комнате.
    Для этого объект, который несет в себе информацию о создании новой комнаты и
    само название этой комнаты преобразуется в строку, которая с помощью метода sendTextMessage
    рассылается всем клиентам.*/
    void broadcastMessage(const QJsonObject &message);
    /*Данный метод отвечает за обработку полученных от клиента сообщений.
    Изначально мы анализируем, от кого пришла информация. Далее проверяем,
    валидное ли сообщение получено. После прохождения проверки преобразуем сообщение
    в объект и получаем его тип.Далее уже предусмотрены три варианта:
        1) Тип сообщения == "create_room". В данном случае мы получаем имя комнаты, которая
    должна быть создана и если такой комнаты не существует, то создаем ее, при этом добавив
    создателя в нее, уведомив его, а также уведомив всех подключенных клиентов осозданной комнате.
    Если же такая комната уже существует, то уведомляем пользователя об этом.
        2) Тип сообщения == "join_room". Здесь мы проверяем, имеется ли комната с таким названием,
    а также свободно ли в ней место. Если условия выполняются, то добавляем пользователя в комнату
    и отправляем обоим игрокам сообщение "game_start".
    Иначе Отправляем сообщение об ошибке.
        3) Тип сообщение == "play". Здесь перенаправляем выбранный игроком объект в
    метод handleGameMovce() который решает, кто победил.*/
    void processMessage(QString message);
    /*Данный метод обрабатывает ход игрока. Изначально определяется, в какой комнате
    находится игрок, который произвел действие, если ее такой комнаты не нашлось,
    то работа метода прерывается. Далее записываем действие, которое произвел игрок и
    если каждый пользователь сделал выбор, то вызывается метод determineWinner(), для
    определения итога игры. После чего игроки уведомляются о результате,
    а комната и их действия удаляются.*/
    void handleGameMove(QWebSocket *socket, QJsonObject obj);
    /*Метод используется для отправки сообщения клиенту. Принимает указатель на сокет socket,
    которому нужно отправить сообщение и само сообщение message.*/
    void sendToClient(QWebSocket *socket, QJsonObject message);
    /*Метод отвечающий за рассылку сообщения всем участникам комнаты.
    Принимает на вход: roomName - название комнаты, message - сообщение*/
    void sendToRoom(const QString &roomName, QJsonObject message);
    /*Метод определяющий победителя. Получает на вход: p1 - выбор первого игрока
     p2 - выбор второго игрока.*/
    QString determineWinner(const QString &p1, const QString &p2);

    QWebSocketServer *server;
    QSet<QWebSocket *> clients;
    QMap<QString, QPair<QWebSocket *, QWebSocket *>> rooms;
    QMap<QString, QPair<QString, QString>> moves;

private slots:
    /*Записываем информацию о подключившемся клиенте,
    перед этим подключив сигналы о получении сообщения
    и отключении клиента от сервера, к обрабатывающим их сигналам.*/
    void onNewConnection();
    /*Данный метод отвественнен за удаление информации о клиенте, после его отключения.
    Для этого мы преобразуем объект, вызвавший сигнал в сокет,
    после этого проходимся по всем комнатам и проверяем, находится ли он в них.
    Если да, то высылаем другому игроку сообщение об отключении оппонента.
    Далее стираем удаляем ход этого игрока и удаляем комнату.
    После чего удаляем сокет из списка сокетов и удаляем сам объект.*/
    void onClientDisconnected();
};

#endif // SERVER_H
